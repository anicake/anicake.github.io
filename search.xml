<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java并发编程之线程池的使用(一)</title>
      <link href="/2019/10/30/bing-fa-bian-cheng-zhi-xian-cheng-chi-yi/"/>
      <url>/2019/10/30/bing-fa-bian-cheng-zhi-xian-cheng-chi-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><hr><p>在工作中我们在有的业务需要异步处理时可以新创建一个线程去处理，这样看起来很简便，但是并发量大的时候，我们会创建大量的线程，并且线程执行的时间很短就结束了，这样频繁的创建和销毁线程，大大的降低了系统的效率，并且线程的利用率也不高。<br>我们就需要解决这个问题让线程可以复用，这个线程执行完任务，可以继续执行别的任务，而不是直接销毁。这时候我们可以使用java提供的线程池来达到我们的需求。</p><h2 id="Java中的ThreadPoolExecutor类"><a href="#Java中的ThreadPoolExecutor类" class="headerlink" title="Java中的ThreadPoolExecutor类"></a>Java中的ThreadPoolExecutor类</h2><hr><p>ThreadPoolExecutor类是jdk自带的创建线程池核心的类，如果想要创建线程池必须理解这个类，下面我们一起来看这个类的源码：<br>ThreadPoolExecutor有四个构造方法</p><pre class="line-numbers language-bash"><code class="language-bash">public ThreadPoolExecutor<span class="token punctuation">(</span>int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>    <span class="token punctuation">}</span>public ThreadPoolExecutor<span class="token punctuation">(</span>int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue,        ThreadFactory threadFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>    <span class="token punctuation">}</span>    public ThreadPoolExecutor<span class="token punctuation">(</span>int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue,        RejectedExecutionHandler handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>    <span class="token punctuation">}</span> public ThreadPoolExecutor<span class="token punctuation">(</span>int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue,            ThreadFactory threadFactory,RejectedExecutionHandler handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>构造方法参数</strong></p><ul><li><strong>1、corePoolSize</strong>：核心线程数。线程池在创建的时候默认不会创建线程，当有任务添加进来时就会创建新的线程，当线程数量达到corePoolSize的时候，新加的任务会被添加到BlockingQueue（阻塞队列）中去；</li><li><strong>2、maximumPoolSize</strong>：线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程；</li><li><strong>3、keepAliveTime</strong>：空闲线程保持活性的时间；默认情况下keepAliveTime只有当线程池中的线程数大于corePoolSize时才会起作用，直到线程中的线程数量小于corePoolSize，如果需要小于corePoolSize时也让keepAliveTime有起作用需要调用allowCoreThreadTimeOut(boolean)方法</li><li><strong>4、unit</strong>：keepAliveTime时间单位；<pre class="line-numbers language-bash"><code class="language-bash">TimeUnit.DAYS<span class="token punctuation">;</span>               //天TimeUnit.HOURS<span class="token punctuation">;</span>             //小时TimeUnit.MINUTES<span class="token punctuation">;</span>           //分钟TimeUnit.SECONDS<span class="token punctuation">;</span>           //秒TimeUnit.MILLISECONDS<span class="token punctuation">;</span>      //毫秒TimeUnit.MICROSECONDS<span class="token punctuation">;</span>      //微妙TimeUnit.NANOSECONDS<span class="token punctuation">;</span>       //纳秒<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>_ <strong>5、workQueue</strong>:一个阻塞队列，线程池创建的线程的数量大于corePoolSize时需要将后面加入的任务放入阻塞队列，这个参数的选择也很重要，对创建什么样线程池有很大的影响。一般有以下几种选择；<br>ArrayBlockingQueue;是一个有界阻塞队列，此队列按先进先出的（FIFO）顺序。<br>LinkedBlockingQueue;默认是一个无界阻塞队列可以指定大小，此队列也是按照先进先出的顺序。吞吐量大于ArrayBlockingQueue。<br>SynchronousQueue; 没有容量，是无缓冲等待队列，是一个不存储元素的阻塞队列，会直接将任务交给消费者，必须等队列中的添加元素被消费后才能继续添加新的元素。<br>PriorityBlockingQueue;一个具有优先级的无限阻塞队列。</li><li><strong>6、threadFactory</strong>：创建线程的线程工厂；</li><li><strong>7、handler</strong>：当线程池饱和的时候拒绝策略。线程池默认提供了四种拒绝策略：<br>AbortPolicy：直接抛出RejectedExecutionException异常。（线程池默认使用的策略）<br>DiscardPolicy：什么都不处理，直接将任务丢弃。<br>DiscardOldestPolicy：丢弃阻塞队列最前面的任务，执行这个任务。<br>CallerRunsPolicy：使用调用者的线程执行当前任务。<br>可以自定义自己的拒绝策略只要实现RejectedExecutionHandler这个类就可以</li></ul><p><strong>几个重要的字段</strong></p><pre class="line-numbers language-bash"><code class="language-bash">private final AtomicInteger ctl <span class="token operator">=</span> new AtomicInteger<span class="token punctuation">(</span>ctlOf<span class="token punctuation">(</span>RUNNING, 0<span class="token punctuation">))</span><span class="token punctuation">;</span> //ctl是用来对线程池的工作线程（workerCount）数和线程池的工作状态（runSate）控制的变量private static final int COUNT_BITS <span class="token operator">=</span> Integer.SIZE - 3<span class="token punctuation">;</span>  // 29private static final int CAPACITY   <span class="token operator">=</span> <span class="token punctuation">(</span>1 <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">)</span> - 1<span class="token punctuation">;</span> //线程池最大容量// runState is stored <span class="token keyword">in</span> the high-order bitsprivate static final int RUNNING    <span class="token operator">=</span> -1 <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>private static final int SHUTDOWN   <span class="token operator">=</span>  0 <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>private static final int STOP       <span class="token operator">=</span>  1 <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>private static final int TIDYING    <span class="token operator">=</span>  2 <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>private static final int TERMINATED <span class="token operator">=</span>  3 <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>线程池的五种状态</strong></p><ul><li><strong>1、RUNNING</strong>：线程池处于工作状态，可以接受新提交的任务到线程池中。</li><li><strong>2、SHUTDOWN</strong>：关闭状态，在线程池为RUNNING状态调用shutdown()方法，此时线程池不会接收新的任务，会将已经线程池中任务执行完。</li><li><strong>3、STOP</strong>：停止状态，线程池在RUNNING或SHUTDOWN状态时可以调用shutdownNow()方法,此时线程池不会接收新提交的任务，也不会处理线程池中处于阻塞队列中的任务。</li><li><strong>4、TIDYING</strong>：当线程池中所有的任务都终止了线程池不在RUNNING状态，且阻塞队列中没有任务，调用terminated()方法，线程池会进入到TERMINATED </li><li><em><em>5、TERMINATED </em></em>：调用terminated()方法后会进入到TERMINATED状态中，ThreadPoolExecutor默认什么都不做。<br>下图为线程池流转的状态：<br><img src="xianchengchi1.png" alt></li></ul><hr><p><strong>线程池中几个重要的方法</strong><br>execute(Runnable command);<br>submit(Runnable task);<br>shutdown();<br>shutdownNow();<br>isTerminated();<br><strong>任务提交执行</strong><br>1、可以用execute(Runnable command)和submit(Runnable task)来提交任务。<br>(1)、用execute提交的任务是没有返回值的，提交之后是无法知道任务执行是否成功</p><pre class="line-numbers language-bash"><code class="language-bash">public void execute<span class="token punctuation">(</span>Runnable command<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> null<span class="token punctuation">)</span>        throw new NullPointerException<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    int c <span class="token operator">=</span> ctl.get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    //判断目前工作的线程是否已经达到核心线程数    <span class="token keyword">if</span> <span class="token punctuation">(</span>workerCountOf<span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>        //任务提交到线程池中执行并维护线程池中工作线程数<span class="token punctuation">(</span>里面有线程池状态和线程数的校验<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>addWorker<span class="token punctuation">(</span>command, true<span class="token punctuation">))</span>        //执行成功直接返回            <span class="token keyword">return</span><span class="token punctuation">;</span>        c <span class="token operator">=</span> ctl.get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    //判断线程池是否在运行状态，将任务加到阻塞队列中去    <span class="token keyword">if</span> <span class="token punctuation">(</span>isRunning<span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> workQueue.offer<span class="token punctuation">(</span>command<span class="token punctuation">))</span> <span class="token punctuation">{</span>        int recheck <span class="token operator">=</span> ctl.get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        //重复判断当前状态是否是运行状态，如果不是则将加入队列的任务出队        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> isRunning<span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> remove<span class="token punctuation">(</span>command<span class="token punctuation">))</span>        //执行线程池的拒绝策略            reject<span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>            //  1. 当前线程池处于 Running 状态，但是工作线程数量为 0，            //      需要创建新的线程            //  2. 移除任务失败，但是工作线程数量为 0，            //      需要创建新的线程来完成移除失败的任务            //            //  因为前面对任务做了判断，所以正常情况下向 addWorker 里传入的任务            //  不可能为 null，这里传入 null 是告诉 addWorker 需要创建新的线程，            //  在 addWorker 里对 null 有专门的处理逻辑        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>workerCountOf<span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">==</span> 0<span class="token punctuation">)</span>            addWorker<span class="token punctuation">(</span>null, false<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    //说明线程池不是 Running 状态或者任务队列满了，    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>addWorker<span class="token punctuation">(</span>command, false<span class="token punctuation">))</span>    //执行拒绝策略        reject<span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>举个栗子：ExecutorService executor <span class="token operator">=</span> new ThreadPoolExecutor<span class="token punctuation">(</span>5,10,500, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> 0<span class="token punctuation">;</span> i<span class="token operator">&lt;</span> 10 <span class="token punctuation">;</span>i++<span class="token punctuation">)</span> <span class="token punctuation">{</span>    int finalI <span class="token operator">=</span> i<span class="token punctuation">;</span>    executor.execute<span class="token punctuation">(</span>new Runnable<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        @Override        public void run<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System.out.println<span class="token punctuation">(</span>Thread.currentThread<span class="token punctuation">(</span><span class="token punctuation">)</span>.getName<span class="token punctuation">(</span><span class="token punctuation">)</span> + <span class="token string">"执行。。。。。。"</span>+ finalI<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="xianchengchi2.png" alt><br>(2)、submit方法用于提交一个任务并带有返回值，这个方法将返回一个Future类型对象。可以通过这个返回对象判断任务是否执行成功，并且可以通过future.get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成。</p><pre class="line-numbers language-bash"><code class="language-bash">//如果执行成功则返回null，执行失败抛出异常public Future<span class="token operator">&lt;</span>?<span class="token operator">></span> submit<span class="token punctuation">(</span>Runnable task<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token operator">==</span> null<span class="token punctuation">)</span> throw new NullPointerException<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    RunnableFuture<span class="token operator">&lt;</span>Void<span class="token operator">></span> ftask <span class="token operator">=</span> newTaskFor<span class="token punctuation">(</span>task, null<span class="token punctuation">)</span><span class="token punctuation">;</span>    execute<span class="token punctuation">(</span>ftask<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ftask<span class="token punctuation">;</span><span class="token punctuation">}</span>//执行成功返回执行成功返回值result，执行失败抛出异常public <span class="token operator">&lt;</span>T<span class="token operator">></span> Future<span class="token operator">&lt;</span>T<span class="token operator">></span> submit<span class="token punctuation">(</span>Runnable task, T result<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token operator">==</span> null<span class="token punctuation">)</span> throw new NullPointerException<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    RunnableFuture<span class="token operator">&lt;</span>T<span class="token operator">></span> ftask <span class="token operator">=</span> newTaskFor<span class="token punctuation">(</span>task, result<span class="token punctuation">)</span><span class="token punctuation">;</span>    execute<span class="token punctuation">(</span>ftask<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ftask<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>举个栗子：</p><pre class="line-numbers language-bash"><code class="language-bash">ExecutorService executor <span class="token operator">=</span>                new ThreadPoolExecutor<span class="token punctuation">(</span>5,10,500, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> new ArrayList<span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>FutureTask<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> task1 <span class="token operator">=</span> new FutureTask<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span><span class="token punctuation">(</span>new Callable<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    @Override    public List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> call<span class="token punctuation">(</span><span class="token punctuation">)</span> throws Exception <span class="token punctuation">{</span>        list.add<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> list<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Future<span class="token operator">&lt;</span>?<span class="token operator">></span> future1 <span class="token operator">=</span>  executor.submit<span class="token punctuation">(</span>task1<span class="token punctuation">)</span><span class="token punctuation">;</span>try <span class="token punctuation">{</span>    System.out.println<span class="token punctuation">(</span>future1.get<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span><span class="token punctuation">}</span> catch <span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    executor.shutdownNow<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>FutureTask<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> task2 <span class="token operator">=</span> new FutureTask<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span><span class="token punctuation">(</span>new Callable<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    @Override    public List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> call<span class="token punctuation">(</span><span class="token punctuation">)</span> throws Exception <span class="token punctuation">{</span>        list.add<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> list<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Future<span class="token operator">&lt;</span>?<span class="token operator">></span> future2 <span class="token operator">=</span>  executor.submit<span class="token punctuation">(</span>task2,list<span class="token punctuation">)</span><span class="token punctuation">;</span>try <span class="token punctuation">{</span>    System.out.println<span class="token punctuation">(</span>future2.get<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span><span class="token punctuation">}</span> catch <span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    executor.shutdownNow<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果 null [1,1]<br><strong>关闭线程池</strong><br>1、shutdown()这个方法将线程池的状态设置为SHUTDOWN，关闭外部提交任务的通道，但是线程池内部的阻塞队列中的任务还是继续执行的，并不会立即停止<br>2、shutdownNow()这个方法是将线程池的状态设置为STOP，会关闭外部提交任务的通道，线程池正在执行的任务会被中止忽略队列里等待的任务，并且会返回未执行的任务列表。<br>3、isTerminated()这个方法线程池正常完成都是返回true，当线程池调用shutdown()后，待线程池中所有的任务都执行完成则返回true,当线程池调用shutdownNow()后，线程池中止所有任务后返回true.<br><strong>其他方法</strong><br>executor.getActiveCount();返回活跃线程数<br>executor.getCorePoolSize();返回线程池的核心线程数<br>executor.getTaskCount();返回线程池中的任务总数<br>executor.getMaximumPoolSize();返回线程池的最大线程数<br>executor.getQueue(); 获取当前线程池的阻塞队列<br>……<br>……</p>]]></content>
      
      
      <categories>
          
          <category> 线程池 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 并发编程 </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>由浅入深理解java集合框架(一)集合Collection</title>
      <link href="/2019/10/20/you-qian-ru-shen-li-jie-java-ji-he-kuang-jia-yi-ji-he-collection/"/>
      <url>/2019/10/20/you-qian-ru-shen-li-jie-java-ji-he-kuang-jia-yi-ji-he-collection/</url>
      
        <content type="html"><![CDATA[<h1 id="java集合类简介"><a href="#java集合类简介" class="headerlink" title="java集合类简介"></a>java集合类简介</h1><hr><p>java集合大致分为List、Set、Queue、Map四种体系，其中List为有序的可重复的集合，Set无序且不可重复的集合，Queue是java 5之后新增的基于队列实现的集合。<br>java的集合就像一个容器，可以把多个对象扔进去，支持对容器中增、删、改、查、迭代等操作。</p><h1 id="java集合和数组的区别"><a href="#java集合和数组的区别" class="headerlink" title="java集合和数组的区别"></a>java集合和数组的区别</h1><hr><p>1、数组的长度需要在初始化固定，意味着数组最多只能保存定长的数据，而集合可以保存不确定长度的数据<br>2、数组可以保存基本数据类型的数据，也可以保存对象类型的数据，集合只能保存对象类型的数据（指对象的引用）</p><h1 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h1><hr><p>List是一个有序且可重复的集合，list默认按照添加元素的顺序设置元素的索引，用户可以通过索引直接访问list集合中的元素。List接口中包含以下方法：<br><img src="list1.png" alt><br><img src="list2.png" alt></p><h2 id="List集合实现之ArrayList"><a href="#List集合实现之ArrayList" class="headerlink" title="List集合实现之ArrayList"></a>List集合实现之ArrayList</h2><p>ArrayList线程不安全底层是基于数组的数据结构实现的，数组长度不够时通过reSize扩容每次扩容当前长度的一半来实现动态数组。由于ArrayList底层的数据结构为数组，每个元素都有对应的索引，因此ArrayList也和数组一样具有随机访问的能力适合随机查找和遍历，不适合经常需要插入和删除操作。<br>ArrayList添加元素</p><pre class="line-numbers language-bash"><code class="language-bash">    public boolean add<span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ensureCapacityInternal<span class="token punctuation">(</span>size + 1<span class="token punctuation">)</span><span class="token punctuation">;</span>  // Increments modCount<span class="token operator">!</span><span class="token operator">!</span>        elementData<span class="token punctuation">[</span>size++<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ArrayList扩容</p><pre class="line-numbers language-bash"><code class="language-bash">    private void grow<span class="token punctuation">(</span>int minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        // overflow-conscious code        int oldCapacity <span class="token operator">=</span> elementData.length<span class="token punctuation">;</span>        int newCapacity <span class="token operator">=</span> oldCapacity + <span class="token punctuation">(</span>oldCapacity <span class="token operator">>></span> 1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity - minCapacity <span class="token operator">&lt;</span> 0<span class="token punctuation">)</span>            newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity - MAX_ARRAY_SIZE <span class="token operator">></span> 0<span class="token punctuation">)</span>            newCapacity <span class="token operator">=</span> hugeCapacity<span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        // minCapacity is usually close to size, so this is a win:        elementData <span class="token operator">=</span> Arrays.copyOf<span class="token punctuation">(</span>elementData, newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="List集合实现之LinkedList"><a href="#List集合实现之LinkedList" class="headerlink" title="List集合实现之LinkedList"></a>List集合实现之LinkedList</h2><p>LinkedList是线程不安全底层基于双向链表实现的集合，链表的特点:插入和删除比较快，不支持随机访问所以查询和遍历比较慢，可以用来当作堆、栈、队列、双向队列的底层数据结构。</p><h2 id="List集合实现之Vector"><a href="#List集合实现之Vector" class="headerlink" title="List集合实现之Vector"></a>List集合实现之Vector</h2><p>Vector是线程安全的，也就是说是它的方法之间是线程同步的，底层的存储的数据和ArrayList一样都是数组</p><h1 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h1><hr><p>Set是无需且不可重复的集合判断两个对象是否重复是用的equals而不是==，元素添加添加进集合是无序的，用户无法通过索引直接对Set中的集合进行访问，Set集合接口中包含以下方法：<br><img src="set1.png" alt></p><h2 id="Set集合实现之HashSet"><a href="#Set集合实现之HashSet" class="headerlink" title="Set集合实现之HashSet"></a>Set集合实现之HashSet</h2><p>HashSet有以下特点</p><ul><li>不能保证元素的排列顺序，顺序有可能发生变化</li><li>不是同步的</li><li>集合元素可以是null,但只能放入一个null<br>HashSet是采用hash表来实现的用hashMap来存储数据。其中的元素没有按顺序排列，add()、remove()以及contains()等方法都是复杂度为O(1)的方法。</li></ul><h2 id="Set集合实现之LinkedHashSet"><a href="#Set集合实现之LinkedHashSet" class="headerlink" title="Set集合实现之LinkedHashSet"></a>Set集合实现之LinkedHashSet</h2><p>LinkedHashSet介于HashSet和TreeSet之间。它也是一个hash表，但是同时维护了一个双链表来记录插入的顺序。基本方法的复杂度为O(1)。</p><h2 id="Set集合实现之TreeSet"><a href="#Set集合实现之TreeSet" class="headerlink" title="Set集合实现之TreeSet"></a>Set集合实现之TreeSet</h2><p>TreeSet是采用树结构实现(红黑树算法)。元素是按顺序进行排列，但是add()、remove()以及contains()等方法都是复杂度为O(log (n))的方法。它还提供了一些方法来处理排序的set，如first(), last(), headSet(), tailSet()等等。</p><h1 id="Queue集合"><a href="#Queue集合" class="headerlink" title="Queue集合"></a>Queue集合</h1><hr><p>Queue集合底层采用的是队列的数据结构，队列是一种特殊的线性列表，它只允许从前端(front)进行出队操作，从后端进行插入操作。在队列这种数据结构中，最先插入的元素将是最先被删除的元素；反之最后插入的元素将是最后被删除的元素，因此队列又称为“先进先出”（FIFO—first in first out）的线性表。Queue集合接口方法:<br><img src="queue1.png" alt></p><h2 id="Queue集合实现之PriorityQueue"><a href="#Queue集合实现之PriorityQueue" class="headerlink" title="Queue集合实现之PriorityQueue"></a>Queue集合实现之PriorityQueue</h2><hr><p>PriorityQueue是一种比较标准的队列实现类，而不是绝对标准的。这是因为PriorityQueue保存队列元素的顺序不是按照元素添加的顺序来保存的，而是在添加元素的时候对元素的大小排序后再保存的。因此在PriorityQueue中使用peek()或pool()取出队列中头部的元素，取出的不是最先添加的元素，而是最小的元素。<br>PriorityQueue不允许插入null元素，它还需要对队列元素进行排序，PriorityQueue有两种排序方式：</p><p>自然排序：采用自然排序的PriorityQueue集合中的元素必须实现Comparator接口，而且应该是一个类的多个实例，否则可能导致ClassCastException异常。</p><pre class="line-numbers language-bash"><code class="language-bash">PriorityQueue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> queue2 <span class="token operator">=</span> new PriorityQueue<span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>queue2.offer<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>queue2.offer<span class="token punctuation">(</span>3<span class="token punctuation">)</span><span class="token punctuation">;</span>queue2.offer<span class="token punctuation">(</span>2<span class="token punctuation">)</span><span class="token punctuation">;</span>queue2.offer<span class="token punctuation">(</span>4<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue2.isEmpty<span class="token punctuation">(</span><span class="token punctuation">))</span> <span class="token punctuation">{</span>    System.out.println<span class="token punctuation">(</span>queue2.poll<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出&gt;&gt;&gt;&gt;&gt; 1 2 3 4</p><p>定制排序：创建PriorityQueue队列时，传入一个Comparable对象，该对象负责对所有队列中的所有元素进行排序。采用定制排序不要求必须实现Comparator接口。</p><pre class="line-numbers language-bash"><code class="language-bash">PriorityQueue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> queue <span class="token operator">=</span> new PriorityQueue<span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>new Comparator<span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    @Override    public int compare<span class="token punctuation">(</span>Integer o1, Integer o2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> o2 - o1<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>queue.offer<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>queue.offer<span class="token punctuation">(</span>3<span class="token punctuation">)</span><span class="token punctuation">;</span>queue.offer<span class="token punctuation">(</span>2<span class="token punctuation">)</span><span class="token punctuation">;</span>queue.offer<span class="token punctuation">(</span>4<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue.isEmpty<span class="token punctuation">(</span><span class="token punctuation">))</span> <span class="token punctuation">{</span>    System.out.println<span class="token punctuation">(</span>queue.poll<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出&gt;&gt;&gt;&gt;&gt; 4 3 2 1</p><h2 id="Queue集合之DeQueue接口与实现ArrayDeque"><a href="#Queue集合之DeQueue接口与实现ArrayDeque" class="headerlink" title="Queue集合之DeQueue接口与实现ArrayDeque"></a>Queue集合之DeQueue接口与实现ArrayDeque</h2><hr><p>Deque接口是Queue接口的子接口，它代表一个双端队列，Deque定义了一些方法：</p><pre class="line-numbers language-bash"><code class="language-bash">void addFirst<span class="token punctuation">(</span>Object e<span class="token punctuation">)</span>: 　　将指定元素添加到双端队列的头部。void addLast<span class="token punctuation">(</span>Object e<span class="token punctuation">)</span>:　　将指定元素添加到双端队列的尾部。Iteratord descendingItrator<span class="token punctuation">(</span><span class="token punctuation">)</span>:　　返回该双端队列对应的迭代器，该迭代器以逆向顺序来迭代队列中的元素。Object getFirst<span class="token punctuation">(</span><span class="token punctuation">)</span>:　　获取但不删除双端队列的第一个元素。Object getLast<span class="token punctuation">(</span><span class="token punctuation">)</span>:　　获取但不删除双端队列的最后一个元素。boolean offFirst<span class="token punctuation">(</span>Object e<span class="token punctuation">)</span>:　　将指定元素添加到双端队列的头部。boolean offLast<span class="token punctuation">(</span>OBject e<span class="token punctuation">)</span>:　　将指定元素添加到双端队列的尾部。Object peekFirst<span class="token punctuation">(</span><span class="token punctuation">)</span>:　　获取但不删除双端队列的第一个元素；如果双端队列为空，则返回null。Object PeekLast<span class="token punctuation">(</span><span class="token punctuation">)</span>:　　获取但不删除双端队列的最后一个元素；如果双端队列为空，则返回null。Object pollFirst<span class="token punctuation">(</span><span class="token punctuation">)</span>:　　获取并删除双端队列的第一个元素；如果双端队列为空，则返回null。Object pollLast<span class="token punctuation">(</span><span class="token punctuation">)</span>:　　获取并删除双端队列的最后一个元素；如果双端队列为空，则返回null。Object pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>栈方法<span class="token punctuation">)</span>:　　pop出该双端队列所表示的栈的栈顶元素。相当于removeFirst<span class="token punctuation">(</span><span class="token punctuation">)</span>。void push<span class="token punctuation">(</span>Object e<span class="token punctuation">)</span><span class="token punctuation">(</span>栈方法<span class="token punctuation">)</span>：　　将一个元素push进该双端队列所表示的栈的栈顶。相当于addFirst<span class="token punctuation">(</span><span class="token punctuation">)</span>。Object removeFirst<span class="token punctuation">(</span><span class="token punctuation">)</span>:　　获取并删除该双端队列的第一个元素。Object removeFirstOccurence<span class="token punctuation">(</span>Object o<span class="token punctuation">)</span>:　　删除该双端队列的第一次出现的元素o。Object removeLast<span class="token punctuation">(</span><span class="token punctuation">)</span>:　　获取并删除该双端队列的最后一个元素o。Object removeLastOccurence<span class="token punctuation">(</span>Object o<span class="token punctuation">)</span>:　　删除该双端队列的最后一次出现的元素o。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>利用ArrayDequeue实现栈,输出结果&gt;&gt;&gt;&gt;&gt;安妮de小熊</p><pre class="line-numbers language-bash"><code class="language-bash">ArrayDeque<span class="token operator">&lt;</span>String<span class="token operator">></span> deque <span class="token operator">=</span> new ArrayDeque<span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>deque.push<span class="token punctuation">(</span><span class="token string">"熊"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>deque.push<span class="token punctuation">(</span><span class="token string">"小"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>deque.push<span class="token punctuation">(</span><span class="token string">"de"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>deque.push<span class="token punctuation">(</span><span class="token string">"妮"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>deque.push<span class="token punctuation">(</span><span class="token string">"安"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>deque.isEmpty<span class="token punctuation">(</span><span class="token punctuation">))</span> <span class="token punctuation">{</span>    System.out.println<span class="token punctuation">(</span>deque.pop<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Collection </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
            <tag> 集合框架 </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>由浅入深理解java集合框架(三)集合LinkedHashMap</title>
      <link href="/2019/10/20/you-qian-ru-shen-li-jie-java-ji-he-kuang-jia-san-ji-he-linkedhashmap/"/>
      <url>/2019/10/20/you-qian-ru-shen-li-jie-java-ji-he-kuang-jia-san-ji-he-linkedhashmap/</url>
      
        <content type="html"><![CDATA[<h1 id="Map简介"><a href="#Map简介" class="headerlink" title="Map简介"></a>Map简介</h1><hr><p>map是一种映射的数据结构，以key-value键值对的形式存储，java中自带了有多种map的实现，也提供了一个用于帮助我们实现自己的Map的抽象类AbstractMap</p><h1 id="java-Map实现之LinkedHashMap"><a href="#java-Map实现之LinkedHashMap" class="headerlink" title="java Map实现之LinkedHashMap"></a>java Map实现之LinkedHashMap</h1><hr><h2 id="LinkedHashMap简介"><a href="#LinkedHashMap简介" class="headerlink" title="LinkedHashMap简介"></a>LinkedHashMap简介</h2><hr><p>在了解了<a href="https://anicake.github.io/2019/10/20/you-qian-ru-shen-li-jie-java-ji-he-kuang-jia-er-ji-he-hashmap" target="_blank" rel="noopener">HashMap</a>我们知道HashMap在put元素时是无序的，元素的位置是根据元素的key计算出来的。当我们的业务需要map具有按插入顺序排序能力的时候，LinkedHashMap是具备这样按插入顺序排序的能力的底层是双向列表和数组的数据结构，LinkedHashMap继承了HashMap重写了HashMap中的部分方法。简单写一个程序</p><pre class="line-numbers language-bash"><code class="language-bash">Map<span class="token operator">&lt;</span>String,Integer<span class="token operator">></span> map <span class="token operator">=</span> new LinkedHashMap<span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map.put<span class="token punctuation">(</span><span class="token string">"语文"</span>, 1<span class="token punctuation">)</span><span class="token punctuation">;</span>    map.put<span class="token punctuation">(</span><span class="token string">"数学"</span>, 2<span class="token punctuation">)</span><span class="token punctuation">;</span>    map.put<span class="token punctuation">(</span><span class="token string">"英语"</span>, 3<span class="token punctuation">)</span><span class="token punctuation">;</span>    map.put<span class="token punctuation">(</span><span class="token string">"历史"</span>, 4<span class="token punctuation">)</span><span class="token punctuation">;</span>    map.put<span class="token punctuation">(</span><span class="token string">"政治"</span>, 5<span class="token punctuation">)</span><span class="token punctuation">;</span>    map.put<span class="token punctuation">(</span><span class="token string">"地理"</span>, 6<span class="token punctuation">)</span><span class="token punctuation">;</span>    map.put<span class="token punctuation">(</span><span class="token string">"生物"</span>, 7<span class="token punctuation">)</span><span class="token punctuation">;</span>    map.put<span class="token punctuation">(</span><span class="token string">"化学"</span>, 8<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>Map.Entry<span class="token operator">&lt;</span>String,Integer<span class="token operator">></span> entry <span class="token keyword">:</span> map.entrySet<span class="token punctuation">(</span><span class="token punctuation">))</span> <span class="token punctuation">{</span>    System.out.println<span class="token punctuation">(</span>entry.getKey<span class="token punctuation">(</span><span class="token punctuation">)</span> + <span class="token string">"-->"</span>+entry.getValue<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：<br>语文–&gt;1<br>数学–&gt;2<br>英语–&gt;3<br>历史–&gt;4<br>政治–&gt;5<br>地理–&gt;6<br>生物–&gt;7<br>化学–&gt;8</p><h2 id="LinkedHashMap中的重要实现"><a href="#LinkedHashMap中的重要实现" class="headerlink" title="LinkedHashMap中的重要实现"></a>LinkedHashMap中的重要实现</h2><hr><p>HashMap中定义了3个方法：</p><pre class="line-numbers language-bash"><code class="language-bash">// Callbacks to allow LinkedHashMap post-actions    void afterNodeAccess<span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K,V<span class="token operator">></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>    void afterNodeInsertion<span class="token punctuation">(</span>boolean evict<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>    void afterNodeRemoval<span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K,V<span class="token operator">></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>put操作</strong><br>LinkedHashMap没有覆盖HashMap的put方法，所以put操作跟HashMap是一样的。但是它覆盖了newNode方法，也就是说构造新节点的时候，LinkedHashMap跟HashMap是不一样的：</p><pre class="line-numbers language-bash"><code class="language-bash">Node<span class="token operator">&lt;</span>K,V<span class="token operator">></span> newNode<span class="token punctuation">(</span>int hash, K key, V value, Node<span class="token operator">&lt;</span>K,V<span class="token operator">></span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    // 使用Entry双向链表构造节点，而不是HashMap的Node单向链表    LinkedHashMap.Entry<span class="token operator">&lt;</span>K,V<span class="token operator">></span> p <span class="token operator">=</span>        new LinkedHashMap.Entry<span class="token operator">&lt;</span>K,V<span class="token operator">></span><span class="token punctuation">(</span>hash, key, value, e<span class="token punctuation">)</span><span class="token punctuation">;</span>    linkNodeLast<span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> // 更新双向链表，这一操作在HashMap里面是没有的    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当put的元素在map中的key已存在时会调用afterNodeAccess方法:</p><pre class="line-numbers language-bash"><code class="language-bash">void afterNodeAccess<span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K,V<span class="token operator">></span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span> // move node to last    LinkedHashMap.Entry<span class="token operator">&lt;</span>K,V<span class="token operator">></span> last<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>accessOrder <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>last <span class="token operator">=</span> tail<span class="token punctuation">)</span> <span class="token operator">!=</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span> // 使用访问顺序，把节点移动到双向链表的最后面，如果已经在最后面了，不需要进行移动        LinkedHashMap.Entry<span class="token operator">&lt;</span>K,V<span class="token operator">></span> p <span class="token operator">=</span>            <span class="token punctuation">(</span>LinkedHashMap.Entry<span class="token operator">&lt;</span>K,V<span class="token operator">></span><span class="token punctuation">)</span>e, b <span class="token operator">=</span> p.before, a <span class="token operator">=</span> p.after<span class="token punctuation">;</span>        p.after <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> null<span class="token punctuation">)</span> // 特殊情况，处理头节点            <span class="token function">head</span> <span class="token operator">=</span> a<span class="token punctuation">;</span>        <span class="token keyword">else</span>            b.after <span class="token operator">=</span> a<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">!=</span> null<span class="token punctuation">)</span> //处理节点            a.before <span class="token operator">=</span> b<span class="token punctuation">;</span>        <span class="token keyword">else</span>            last <span class="token operator">=</span> b<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>last <span class="token operator">==</span> null<span class="token punctuation">)</span> //// 特殊情况，处理尾节点            <span class="token function">head</span> <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            p.before <span class="token operator">=</span> last<span class="token punctuation">;</span>            last.after <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">tail</span> <span class="token operator">=</span> p<span class="token punctuation">;</span>        ++modCount<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果key不存在则会调用afterNodeInsertion方法:</p><pre class="line-numbers language-bash"><code class="language-bash">void afterNodeInsertion<span class="token punctuation">(</span>boolean evict<span class="token punctuation">)</span> <span class="token punctuation">{</span> // possibly remove eldest    LinkedHashMap.Entry<span class="token operator">&lt;</span>K,V<span class="token operator">></span> first<span class="token punctuation">;</span>    //removeEldestEntry方法LinkedHashMap永远返回false,如果需要自定义需覆盖这个方法    <span class="token keyword">if</span> <span class="token punctuation">(</span>evict <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>first <span class="token operator">=</span> head<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> removeEldestEntry<span class="token punctuation">(</span>first<span class="token punctuation">))</span> <span class="token punctuation">{</span>        K key <span class="token operator">=</span> first.key<span class="token punctuation">;</span>        removeNode<span class="token punctuation">(</span>hash<span class="token punctuation">(</span>key<span class="token punctuation">)</span>, key, null, false, true<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>get操作</strong><br>LinkedHashMap中重写了HashMap中的get方法：</p><pre class="line-numbers language-bash"><code class="language-bash">public V get<span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K,V<span class="token operator">></span> e<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token variable"><span class="token punctuation">((</span>e <span class="token operator">=</span> getNode<span class="token punctuation">(</span>hash<span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">))</span></span> <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    //如果使用访问顺序则需要执行afterNodeAccess    <span class="token keyword">if</span> <span class="token punctuation">(</span>accessOrder<span class="token punctuation">)</span>        afterNodeAccess<span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> e.value<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>remove操作</strong><br>LinkedHashMap的remove方法没有复写HashMap的remove方法，但是同样实现了afterNodeRemoval这个钩子方法：</p><pre class="line-numbers language-bash"><code class="language-bash">// 更新双向链表void afterNodeRemoval<span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K,V<span class="token operator">></span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span> // unlink    LinkedHashMap.Entry<span class="token operator">&lt;</span>K,V<span class="token operator">></span> p <span class="token operator">=</span>        <span class="token punctuation">(</span>LinkedHashMap.Entry<span class="token operator">&lt;</span>K,V<span class="token operator">></span><span class="token punctuation">)</span>e, b <span class="token operator">=</span> p.before, a <span class="token operator">=</span> p.after<span class="token punctuation">;</span>    p.before <span class="token operator">=</span> p.after <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token function">head</span> <span class="token operator">=</span> a<span class="token punctuation">;</span>    <span class="token keyword">else</span>        b.after <span class="token operator">=</span> a<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token function">tail</span> <span class="token operator">=</span> b<span class="token punctuation">;</span>    <span class="token keyword">else</span>        a.before <span class="token operator">=</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>accessOrder属性分析</strong><br>LinkedHashMap的accessOrder属性默认情况下为false就时按照插入的顺序排序，如果accessOrder属性设置为true则按照访问的顺序，那么afterNodeAccess这个钩子方法内部的逻辑会被执行，LinkedHashMap会在被访问之后修改双向链表的结构。<br>afterNodeAccess在使用get方法或者put方法遇到关键字已经存在的情况下，会被触发。<br><strong>注意事项</strong><br>如果accessOrder设置为true那么使用下面的方法遍历会报错</p><pre class="line-numbers language-bash"><code class="language-bash">for<span class="token punctuation">(</span>String str <span class="token keyword">:</span> map.keySet<span class="token punctuation">(</span><span class="token punctuation">))</span> <span class="token punctuation">{</span>    System.out.println<span class="token punctuation">(</span>map.get<span class="token punctuation">(</span>str<span class="token punctuation">))</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="linkedhashmap1.png" alt><br>需要按照这种方法遍历</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token keyword">for</span> <span class="token punctuation">(</span>Map.Entry<span class="token operator">&lt;</span>String,Integer<span class="token operator">></span> entry <span class="token keyword">:</span> map.entrySet<span class="token punctuation">(</span><span class="token punctuation">))</span> <span class="token punctuation">{</span>    System.out.println<span class="token punctuation">(</span>entry.getKey<span class="token punctuation">(</span><span class="token punctuation">)</span> + <span class="token string">"-->"</span>+entry.getValue<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LinkedHashMap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
            <tag> 集合框架 </tag>
            
            <tag> Map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>由浅入深理解java集合框架(二)集合HashMap</title>
      <link href="/2019/10/20/you-qian-ru-shen-li-jie-java-ji-he-kuang-jia-er-ji-he-hashmap/"/>
      <url>/2019/10/20/you-qian-ru-shen-li-jie-java-ji-he-kuang-jia-er-ji-he-hashmap/</url>
      
        <content type="html"><![CDATA[<h1 id="Map简介"><a href="#Map简介" class="headerlink" title="Map简介"></a>Map简介</h1><hr><p>map是一种映射的数据结构，以key-value键值对的形式存储，java中自带了有多种map的实现，也提供了一个用于帮助我们实现自己的Map的抽象类AbstractMap</p><h1 id="java-Map实现之HashMap"><a href="#java-Map实现之HashMap" class="headerlink" title="java Map实现之HashMap"></a>java Map实现之HashMap</h1><hr><p>java中HashMap是我们日常开发中最常使用的map，HashMap（ jdk1.8以后）底层是基于数组（hash散列）+ 链表 + 红黑树来实现的。 HashMap的优势是可以很快的根据键（key）找到对应的值（value）,HashMap存储的时候是无序的,通过put进来的元素key的hashCode计算该元素在数组上的索引，把元素放到上面去，用链表和红黑树来解决hash碰撞的问题。</p><h2 id="HashMap-put函数的实现"><a href="#HashMap-put函数的实现" class="headerlink" title="HashMap put函数的实现"></a>HashMap put函数的实现</h2><hr><p>下面是我们hashMap中put元素时的操作：</p><pre class="line-numbers language-bash"><code class="language-bash">HashMap<span class="token operator">&lt;</span>String,Integer<span class="token operator">></span> map <span class="token operator">=</span> new HashMap<span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map.put<span class="token punctuation">(</span><span class="token string">"语文"</span>, 1<span class="token punctuation">)</span><span class="token punctuation">;</span>    map.put<span class="token punctuation">(</span><span class="token string">"数学"</span>, 2<span class="token punctuation">)</span><span class="token punctuation">;</span>    map.put<span class="token punctuation">(</span><span class="token string">"英语"</span>, 3<span class="token punctuation">)</span><span class="token punctuation">;</span>    map.put<span class="token punctuation">(</span><span class="token string">"历史"</span>, 4<span class="token punctuation">)</span><span class="token punctuation">;</span>    map.put<span class="token punctuation">(</span><span class="token string">"政治"</span>, 5<span class="token punctuation">)</span><span class="token punctuation">;</span>    map.put<span class="token punctuation">(</span><span class="token string">"地理"</span>, 6<span class="token punctuation">)</span><span class="token punctuation">;</span>    map.put<span class="token punctuation">(</span><span class="token string">"生物"</span>, 7<span class="token punctuation">)</span><span class="token punctuation">;</span>    map.put<span class="token punctuation">(</span><span class="token string">"化学"</span>, 8<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Map.Entry<span class="token operator">&lt;</span>String,Integer<span class="token operator">></span> entry <span class="token keyword">:</span> map.entrySet<span class="token punctuation">(</span><span class="token punctuation">))</span> <span class="token punctuation">{</span>         System.out.println<span class="token punctuation">(</span>entry.getKey<span class="token punctuation">(</span><span class="token punctuation">)</span> + <span class="token string">"-->"</span>+entry.getValue<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-bash"><code class="language-bash">政治--<span class="token operator">></span>5生物--<span class="token operator">></span>7历史--<span class="token operator">></span>4数学--<span class="token operator">></span>2化学--<span class="token operator">></span>8语文--<span class="token operator">></span>1英语--<span class="token operator">></span>3地理--<span class="token operator">></span>6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看一下hashMap内部的数组元素的分布情况：<br><img src="hashmap1.png" alt><br>上图可以清楚的显示出hashMap添加新元素时的bucket位置不是按照添加顺序的，而是通过计算，hash碰撞时会在当前bucket位置产生一个链表存储。<br><strong>1、HashMap中几个比较重要的成员变量和参数</strong></p><ul><li><strong>initialCapacity（参数）</strong>:initialCapacity初始化map的buckets的数量，默认的情况下是16个。</li><li><strong>loadFactor</strong>:loadFactor负载因子默认为0.75f,reSize的条件当前的hashMap的元素的个数大于loadFactor*capacity会将原来的map扩容至原来的2倍。</li><li><strong>table</strong>:用来装hashMap中的元素。</li><li><strong>size</strong>:当前hashMap所有元素的个数。</li></ul><p><strong>2、put函数的大致流程:</strong><br>1、根据key的hashCode()做hash计算如果没发生碰撞直接将元素插入到计算的bucket上<br>2、如果发生了碰撞和判断当前位置的key做equals如果相等则更新该节点的值<br>3、如果发生碰撞但是key并不相等则在该节点需要以链表的形式存储<br>4、当链表的长度大于等于8(TREEIFY_THRESHOLD)链表转为红黑树<br>5、判断当前hashMap的元素个数是否大于（loadFactor*capacity），如果大于进行reSize<br>代码如下：</p><pre class="line-numbers language-bash"><code class="language-bash">final V putVal<span class="token punctuation">(</span>int hash, K key, V value, boolean onlyIfAbsent,                   boolean evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K,V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K,V<span class="token operator">></span> p<span class="token punctuation">;</span> int n, i<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token variable"><span class="token punctuation">((</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab.length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">/</span><span class="token operator">/</span> tab为空则创建        n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> resize<span class="token punctuation">(</span><span class="token punctuation">))</span></span>.length<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token variable"><span class="token punctuation">((</span>p <span class="token operator">=</span> tab[i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash]<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">/</span><span class="token operator">/</span> 计算index，并对null做处理        tab[i] <span class="token operator">=</span> newNode<span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    else {        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span> K k<span class="token punctuation">;</span>        if <span class="token punctuation">(</span>p.hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">((</span>k <span class="token operator">=</span> p.key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key.equals<span class="token punctuation">(</span>k<span class="token punctuation">))</span></span><span class="token punctuation">))</span> //判断节点是否存在相同的key            e <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p instanceof TreeNode<span class="token punctuation">)</span> // 该链为树            e <span class="token operator">=</span> <span class="token variable"><span class="token punctuation">((</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span>.putTreeVal<span class="token punctuation">(</span>this<span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        else {            for <span class="token punctuation">(</span>int binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> {                if <span class="token punctuation">((</span>e <span class="token operator">=</span> p.next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> {                    p.next <span class="token operator">=</span> newNode<span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                    if <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span><span class="token operator">/</span> <span class="token operator">-</span><span class="token number">1</span> for 1st <span class="token operator">/</span><span class="token operator">/</span>链转数                        treeifyBin<span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>                    break<span class="token punctuation">;</span>                }                if <span class="token punctuation">(</span>e.hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">((</span>k <span class="token operator">=</span> e.key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key.equals<span class="token punctuation">(</span>k<span class="token punctuation">))</span></span><span class="token punctuation">))</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                p <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        //节点存在相同的节点，值替换        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> // existing mapping <span class="token keyword">for</span> key            V oldValue <span class="token operator">=</span> e.value<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> null<span class="token punctuation">)</span>                e.value <span class="token operator">=</span> value<span class="token punctuation">;</span>            afterNodeAccess<span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    ++modCount<span class="token punctuation">;</span>    //进行reSize操作    <span class="token keyword">if</span> <span class="token punctuation">(</span>++size <span class="token operator">></span> threshold<span class="token punctuation">)</span>        resize<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    afterNodeInsertion<span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>hashMap的get实现</strong><br>如果理解了put操作get实现就很容易理解了，根据用户传来的key通过hash计算找到对应的索引位置，然后通过equals判断查找对应的key，若为链表查找时间复杂度为O(n)，若为数则时间复杂度为O(logn)。</p><pre class="line-numbers language-bash"><code class="language-bash">public V get<span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K,V<span class="token operator">></span> e<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> getNode<span class="token punctuation">(</span>hash<span class="token punctuation">(</span>key<span class="token punctuation">)</span>, key<span class="token punctuation">))</span> <span class="token operator">==</span> null ? null <span class="token keyword">:</span> e.value<span class="token punctuation">;</span><span class="token punctuation">}</span>final Node<span class="token operator">&lt;</span>K,V<span class="token operator">></span> getNode<span class="token punctuation">(</span>int hash, Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K,V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K,V<span class="token operator">></span> first, e<span class="token punctuation">;</span> int n<span class="token punctuation">;</span> K k<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token variable"><span class="token punctuation">((</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab.length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span>first <span class="token operator">=</span> tab[<span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash]<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> {        if <span class="token punctuation">(</span>first.hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token operator">/</span><span class="token operator">/</span> always check first node            <span class="token punctuation">((</span>k <span class="token operator">=</span> first.key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key.equals<span class="token punctuation">(</span>k<span class="token punctuation">))</span></span><span class="token punctuation">))</span>            <span class="token keyword">return</span> first<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token variable"><span class="token punctuation">((</span>e <span class="token operator">=</span> first.next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> {            if <span class="token punctuation">(</span>first instanceof TreeNode<span class="token punctuation">)</span>                return <span class="token punctuation">((</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>first<span class="token punctuation">)</span>.getTreeNode<span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>            do {                if <span class="token punctuation">(</span>e.hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">((</span>k <span class="token operator">=</span> e.key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key.equals<span class="token punctuation">(</span>k<span class="token punctuation">))</span></span><span class="token punctuation">))</span>                    <span class="token keyword">return</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">((</span>e <span class="token operator">=</span> e.next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>hashMap的hash函数的实现</strong><br>在get和put的过程中，计算下标时，先对hashCode进行hash操作，然后再通过hash值进一步计算下标，如下图所示：<br><img src="hashmap2.png" alt><br>代码具体的逻辑为，根据key计算出的hashCode高16位不变，低16位和高16位做一个异或的运算。代码如下</p><pre class="line-numbers language-bash"><code class="language-bash">static final int hash<span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    int h<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> ? 0 <span class="token keyword">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key.hashCode<span class="token punctuation">(</span><span class="token punctuation">))</span> ^ <span class="token punctuation">(</span>h <span class="token operator">>></span><span class="token operator">></span> 16<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>因为目前的table长度n为2的幂，而计算下标的时候，是这样实现的(使用&amp;位操作，而非%求余)：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">(</span>n - 1<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token function">hash</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> HashMap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
            <tag> 集合框架 </tag>
            
            <tag> Map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客</title>
      <link href="/2019/10/14/di-yi-pian-bo-ke/"/>
      <url>/2019/10/14/di-yi-pian-bo-ke/</url>
      
        <content type="html"><![CDATA[<p>hello world ！！！！！！！！！！！！开启我的博客之旅。。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
